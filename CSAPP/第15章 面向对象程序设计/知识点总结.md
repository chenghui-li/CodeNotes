# 概述
- 面向对象程序设计的核心思想是：**数据抽象，继承和动态绑定**。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似的关系建模；使用动态绑定可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

- 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。在C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为**虚函数**。虚函数的声明形式是：在函数的最前面（返回类型前）加上关键字**virtual**。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
```
class Quote{
public:
	string isbn() const;
	virtual double net_price(size_t n) const;
}
```
- 派生类必须通过使用类派生列表明确指出它是从哪个（哪些）基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前可以有访问说明符。访问说明符的作用是控制派生类从基类继承而来的成员对派生类用户是否可见。如果一个派生是公有的，则基类的公有成员也是派生类的接口的组成部分。此外，还可以将公有派生类型的对象绑定到基类的引用或指针上。
```
class Bulk_quote : public Quote{
public:
	double net_price(size_t n)const override;
}
```

- 派生类必须在其内部对所以重新定义的虚函数进行声明。派生类可以在这些函数前加上virtual关键字，但不是必须这样做。override是C++11新标准规定，用来显式的注明使用哪个成员函数改下基类的虚函数。

- 使用动态绑定可以使用一段代码处理基类和派生类的对象。
```
double print_total(ostream &os,const Quote &item,size_t n){
	double ret = item.net_price(n);
	os<<"ISBN: "<<item.isbn()<<"sold: "<<n<<" total due: "<<ret<<endl;
}
```
因为函数print_total的形参是基类Quote的一个引用，所以，既可以使用基类的对象调用该函数，也可以使用派生类的对象调用该函数。又因为是使用引用类型调用net_price的，所以，实际传入print_total的对象类型将决定到底执行net_price的哪个版本。
```
//basic是基类Quote的一个对象，bulk是派生类的一个对象
print_total(cout,basic,20);
print_total(cout,bulk,20)
```
因为在上述过程中函数的运行版本由实参决定，即在运行时决定函数的版本，所以动态绑定又称为运行时绑定。

- **在C++中，当使用基类的引用或指针调用一个虚函数时，将发生动态绑定。**作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不进行任何操作也是如此。

- 派生类经常但不总是覆盖它继承的虚函数。如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他普通成员函数，派生类会直接继承其在基类中定义的版本。

- 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样子的子对象也有多个。

