# 概要
- 系统调用fork允许一进程（父进程）创建一个新进程（子进程）：新的子进程几近于对父进程的翻版，子进程获得父进程的栈，数据段，堆和执行文本段的拷贝，（即相同的东西，但不是同一份，实际上，操作系统为了提高效率，使用**写时复制**策略）。
- 库函数exit终止一进程，将进程占用的所有资源归还内核，交其进行再次分配。参数status为一整型变量，表示进程的退出状态。父进程可以使用系统调用wait来获取子进程的退出状态。
- 库函数exit位于系统调用_exit之上，父，子进程一般只有一个调用exit终止，另一个调用_exit终止。
- 系统调用wait(&status)的目的有二：1. 如果子进程尚未调用eixt终止，wait会挂起父进程直至子进程终止。2. 子进程的终止状态父进程可以通过wait来获取。
- 系统调用execve(pathname,argv,envp)加载一个新程序到当前进程的内存。这将丢弃现存的程序文本段并为新程序重新创建栈，数据段以及堆。
```
#include<unistd.h>
pid_t fork(void);   //父进程中返回子进程id，子进程中返回0,出错返回-1
```
完成对其调用后，存在两个进程，都从fork的返回处继续执行。这两个进程将执行相同的程序文本段，但却各自拥有不同的栈段，数据段以及堆段的拷贝。
- 执行fork时，子进程会获得父进程所有文件描述符的副本。这些副本的创建方式类似于dup，这也意味着父，子进程中对应的描述符指向相同的打开文件句柄。打开文件句柄包含当前文件偏移量以及文件状态标志。一个打开文件的这些属性因之在父子进程间实现了共享，比如说，一个子进程更新了文件偏移量，那么这种改变也会影响到父进程中的相应描述符。如果不需要这种对文件描述符的共享方式，应于fork调用后注意两点：1. 令父子进程使用不同的文件描述符；2. 各自立即关闭不再使用的描述符。
- 在早期的UNIX系统中，fork调用将父进程内存拷贝至交换空间，以此创建新进程映像，而在父进程保持自身内存的同时，将换出映像置为子进程。但其实这种做法非常的浪费，因为多数fork之后紧随着exec的调用，这会用新程序替换进程的代码段，并重新初始化数据段，堆段，栈段。所以，大部分UNIX实现采用两种方法来避免这种浪费。
1. 内核将每一进程的代码段标记为只读，使进程无法修改自身代码，从而使父子进程共享同一代码段。**系统调用fork在为子进程创建代码段时，其所构建的一系列进程级页表项均指向与父进程相同的物理内存页帧。**
2. 对于父进程数据段，堆段，栈段中的各页，内核采用**写时复制**技术来处理。最初，内核做了一些设置，令这些段的页表项指向与父进程相同的物理内存页。并将这些页面自身标记为只读。调用fork之后，内核会捕获所有父进程或子进程针对这些页面的修改企图，并为将要修改的页面创建拷贝。系统将新的页面拷贝分配给遭内核捕获的进程，还会对子进程的相应页表项做适当调整。
![](https://raw.githubusercontent.com/chenghui-li/blog-photos/master/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6.jpg)

- 类似于fork，vfork可以为调用进程创建一个新的子进程，然而，vfork是为子进程立即执行exec的程序而专门设计的。
```
#include<unistd.h>
pid_t vfork(void)    ////父进程中返回子进程id，子进程中返回0,出错返回-1
``` 
vfork因为两个特性而更具效率，也是区别于fork所在：
1. 无需为子进程复制虚拟内存或页表，子进程共享父进程的内存，直至其成功执行了exec()或是调用_exit()退出。
2. 在子进程调用exec()或_exit()之前，将暂停执行父进程。（即子进程先运行）。
在使用时，一般应立即在vfork之后调用exec，如果exec执行失败，子进程应调用_exit()退出，vfork产生的子进程不应调用exit退出，因为这会导致父进程stdio缓冲区的刷新和关闭。
- 调用fork之后，如果进程甲需等待进程乙完成某些动作，那么进程乙可以在动作完成后向甲发出信号：甲等待即可。
