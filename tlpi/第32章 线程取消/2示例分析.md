# 程序32-1
调用pthread_cancel取消线程
```
#include<pthread.h>
#include "tlpi_hdr.h"
static void *threadFunc(void *arg){
	int j;
	printf("New thead started\n");
	for(int j = 1;;j++){
		printf("Loop %d\n",j);
		sleep(1);
	}
	return NULL;
}
int main(int argc,char *argv[]){
	pthread_t thr;
	int s;
	void *res;
	if((s = pthread_create(&thr,NULL,threadFunc,NULL)) != 0){
		errExit("pthread_create");
	}
	sleep(3);
	if((s = pthread_cancel(thr)) != 0){
		errExit("pthread_cancel");
	}
	if((s = pthread_join(thr,&res))!=0){
		errExit("pthread_join");
	}
	if(res == PTHREAD_CANCELED){
		printf("thread was canceled\n");
	}else{
		printf("thread was not canceled\n");
	}
	exit(0);
}
```
分析：由main创建的线程会执行到属于取消点的函数，因而会接收取消请求。不过，假设线程执行的是一个不含取消点的循环，这时线永远也不会响应取消请求。