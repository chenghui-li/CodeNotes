# 程序分析
## 程序57-1
绑定一个UNIX domain socket
```
const char *SOCKNAME = "/tmp/mysock";
int sfd;
struct sockaddr_un addr;
sfd = socket(AF_UNIX,SOCKNAME,0);
if(sfd == -1){
	exit(1);
}
memset(&addr,0,sizeof(sockaddr_un));
addr.sun_family = AF_UNIX;
strncpy(addr.sun_path,SOCKNAME,sizeof(addr.sun_path)-1);
if(bind(sfd,(struct sockaddr *)&addr,sizeof(struct sockaddr_un)) == -1){
	exit(1);
}
```
分析：memset使得addr中的字段都初始化为0，（其实bzero函数在网络编程中更常用）。strncpy中的第三个参数减一的原因是保证这个字段总是有一个字节可以放结束字符（'\0'）。由于bind的第二个参数类型要求是通用地址struct sockaddr，故需要将其进行类型转换。

## 程序57-3
一个简单的UNIX domain流socket服务器
```
#include<sys/un.h>
#include<sys/socket.h>
#include<stdio.h>
#include<stdlib.h>
#define SV_SOCK_PATH "/tmp/us_xfr"
#define BUF_SIZE 100
#define BACKLOG 5
int main(int argc,char *argv[]){
	struct sockaddr_un addr;
	int sfd,cfd;
	ssize_t numRead;
	char buf[BUF_SIZE];
	sfd = socket(AF_UNIX,SOCK_STREAM,0);
	if(sfd == -1){
		exit(1);
	}
	if(remove(SV_SOCK_PATH) == -1 && errno != ENOENT){
		exit(1);
	}
	memset(&addr,0,sizeof(struct sockaddr_un));
	addr.sun_family = AF_UNIX;
	strncpy(addr.sun_path,SV_SOCK_PATH,sizeof(addr.sun_path)-1);
	if(bind(sfd,(struct sockaddr &)&addr,sizeof(struct sockaddr_un)) == -1){
		exit(1);
	}
	if(listen(sfd,BACKLOG) == -1){
		exit(1);
	}
	while(1){
		cfd = accept(sfd,NULL,NULL);
		if(cfd == -1){
			exit(1);
		}
		while((numRead = read(cfd,buf,BUF_SIZE))>0){
			if(write(STDOUT_FILENO,buf,BUF_SIZE)>0){
				exit(1);
			}
		}
		if(numRead == -1){
			exit(1);
		}
		if(close(cfd) == -1){
			exit(1);
		}
	}
	eixt(0);
}
```
分析：该服务器的功能是从客户端读取传输的内容，然后将其显示到服务器的终端上。其中的remove作用是删除所有与路径名一致的既有文件，这样就能将socket绑定到这个路径名上。

## 程序57-4
一个简单的UNIX domain流socket客户端
```
#include<sys/un.h>
#include<sys/socket.h>
#include<stdio.h>
#include<stdlib.h>
#define SV_SOCK_PATH "/tmp/us_xfr"
#define BUF_SIZE 100
#define BACKLOG 5
int main(int argc,char *argv[]){
	struct sockaddr_un addr;
	int sfd;
	ssize_t numRead;
	char buf[BUF_SIZE];
	sfd = socket(AF_UNIX,SOCK_STREAM,0);
	if(sfd == -1){
		exit(1);
	}
	memset(addr,0,sizeof(struct sockaddr_un));
	addr.sun_family = AF_UNIX;
	strncpy(addr.sun_path,SV_SOCK_PATH,sizeof(addr.sun_path)-1);
	if(connect(sfd,(struct sockaddr *)&addr,sizeof(struct sockaddr_un)) == -1){
		exit(1);
	}
	while((numRead = read(STDIN_FILENO,buf,BUF_SIZE))>0){
		if(write(sfd,buf,numRead) != numRead){
			exit(1);
		}
	}
	if(numRead == -1){
		exit(1);
	}
	eixt(0);
}
```
