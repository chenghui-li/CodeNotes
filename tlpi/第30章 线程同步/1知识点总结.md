# 概述
- **互斥量**可以帮助线程同步对共享资源的使用，以防止如下情况发生：线程a试图访问一共享变量时，线程b正在对其进行修改。**条件变量**则是在此之外的拾遗补缺，允许线程相互通知共享变量（或其他共享资源）的状态发生了变化。

- 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，亦即，同时访问同一共享资源的其他线程不应中断该片段的执行。

- 互斥量有两种状态：已锁定和未锁定。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。

- 互斥量既可以像静态变量那样分配，也可以在运行时动态创建（比如通过malloc在一块内存中分配）。互斥量是属于pthread_mutex_t类型的变量。在使用之前必须对其进行初始化。对于静态分配的互斥量而言，可以这样初始化：
`pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER`。

- 初始化之后，互斥量处于未锁定状态。函数pthread_mutex_lock可以锁定某一互斥量，而函数pthread_mutex_unlock则可以将一个互斥量解锁。
```
#include<pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
//成功返回0，出错返回正整数
```
如果对自身已经锁定的互斥量再调用pthread_mutex_lock进行锁定，会导致两种后果：1）线程陷入死锁；2）调用失败，返回EDEADLK错误，linux默认情况下线程会发生死锁。对未锁定的互斥量或者解锁别的线程锁定的互斥量调用pthread_mutex_unlock解锁均属错误。

- 在大多数良好的设计的应用程序中，线程对互斥量的持有时间应尽可能短，以避免妨碍其他线程的并发执行。这也保证了遭堵塞的其他线程可以很快获取对互斥量的锁定。

- 有时一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当每个线程锁住一个互斥量，接着试图对已被另一线程锁住的互斥量加锁时，线程将无限的等待下去，发生死锁。预防死锁的一个方法是：当多个线程对一组互斥量操作时，总是应该**以相同顺序对该组互斥量进行锁定**。

- 静态初始值PTHREA_MUTEX_INITIALIZER只能用于经由静态分配且携带默认属性的互斥量的初始化，其他情况下，必须调用pthread_mutex_init()对互斥量进行动态初始化。
```
#include<pthread.h>
int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr);
//成功返回0，出错返回正整数
```
参数mutex指定函数执行初始化操作的目标互斥量，attr是指向pthread_mutexattr_t类型的指针，该对象在调用之前已经过了初始化处理，用于定义互斥量的属性。若将attr置为NULL，则该互斥量的各种属性会取默认值。

- 初始化一个已经初始化过的互斥量将导致未定义的行为，应该避免这种操作。

- 如下情况必须调用pthread_mutex_init()：
1. 动态分配于堆中的互斥量。
2. 互斥量是在栈中分配的自动变量。
3. 初始化经由静态分配，且不适用默认属性的互斥量。

- 当不再需要经由自动或动态分配的互斥量时，应使用pthread_mutex_destroy()将其销毁。（对于使用PTHREA_MUTEX_INITIALIZER静态初始化的互斥量，无需调用pthread_mutex_destroy()）
```
#include<pthread.h>
int pthread_mutex_destroy(pthread_mutex_t *mutex);
//成功返回0，出错返回正整数
```
只有当互斥量处于未锁定状态，且后续也无任何线程企图锁定它时，将其销毁才是安全的。若互斥量驻留于动态分配的一片内存中，应该在释放此内存区域前将其销毁。对于自动分配的互斥量，也应该在宿主函数返回前将其销毁。经由pthread_mutex_destroy()销毁的互斥量，可调用pthread_mutex_init()对其重新初始化。

- 