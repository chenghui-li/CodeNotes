# 概述
- 管道是UNIX系统上最古老的IPC方法：给定两个运行不同程序的进程，管道可以实现进程间传递数据，它允许数据从一个进程流向另一个进程。FIFO是管道概念的一个变体，它们之间的一个重要差别在于，FIFO可以用于任意进行间的通信。而管道只能在相关进程间通信，即祖先进程和子孙进程之间的通信。

- 讲到管道是一个字节流时意味着在使用管道时是不存在消息或消息边界的概念的。从管道中读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块大小是什么。此外，通过管道传递的数据是顺序的，也就是说先取出来的数据就是先写入的数据。不可以使用lseek随机读取。

- 试图从一个当前为空的管道中读取数据将会被阻塞直到至少有一个字节被写入到管道中为止。如果管道的写入端被关闭了，那么从管道中读取数据的进程在读完管道中剩余的所有数据之后将会看到文件结束（即read返回0）

- 在管道中传递数据是单向的，即一端用来写入，另一端用来读取。

- 如果多个进程写入同一个管道，那么如果它们在一个时刻写入的数据量不超过PIPE_BUF字节，那么就可以确保写入的数据不会发生相互混合的情况。当写入管道的数据块大小超过了PIPE_BUF字节，那么内核可能会将数据分割成几个较小的片段来传送（此时write阻塞，直到所有数据写入管道），在读者从管道中消耗数据时再加上后续的数据。如果write阻塞时被信号处理程序打断，该阻塞会被解除，并且返回实际写入管道中的字节数。当只有一个进程向管道写入数据时，PIPE_BUF的取值就没有关系了。

- 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的。一旦管道被填满，后续向该管道写入操作就会被阻塞直到读者从管道中移除一些数据。通常缓冲器使用较大点的效率较高，因为：每当写者充满管道时，内核必须要执行一个上下文切换以允许读者被调度来消耗管道中的一些数据。使用较大的缓冲区意味着上下文切换次数更少。

- pipe系统调用可以创建一个新管道
```
#include<unistd.h>
int pipe(int filedes[2]);
//成功返回0，出错返回-1
```
成功的pipe调用会在数组filedes中返回两个打开的文件描述符：一个表示管道的读取端（filedes[0])，另一个表示管道的写入端（filedes[1]）。与所有文件描述符一样，可以使用read和write调用来在管道上执行IO。一旦向管道的写入端写入数据之后，立即就能从管道的读取端读取数据。管道上的read调用会读取的数据量为**所请求的字节数与管道中当前存在的字节数两者之间的较小的那个**。

- 一般来讲都是使用管道让两个进程进行通信。为了让两个进程通过管道进行连接，在调用完pipe之后可以调用fork，子进程会继承父进程的描述符副本，此时还应该关闭各自的一个写入端和读取端。如果想让父进程写入，子进程读取，则应该关闭父进程的读取端和子进程的写入端。

- 关闭管道的读取端和写入端是很重要的，不仅仅是为了避免描述符使用过多超过上限。
**1.当一个管道有多个写入和读取端连入时，如果写端已经完成工作，但是有一个连接没有关闭，则读取端不会看到文件结束。尽管此时已经没有数据可以读，但是内核告诉进程还有一个写描述符连入，此时read会阻塞等待数据。
2.当一个进程试图向一个管道中写入数据但没有任何进程拥有该管道的打开着的读取描述符时，内核会向这个写入进程发送一个SIGPIPE
信号。默认情况下，该信号会杀死一个进程，但进程可以忽略或捕捉该信号，这样就会导致管道上的write操作因EPIPE错误而失败。收到SIGPIPE信号或得到EPIPE错误对于标示出管道的状态是很有用的。
3.只有当所有进程中所有引用一个管道的文件描述符被关闭之后才会销毁该管道以及释放管道占用的资源以供其他进程复用。此时管道中所有未读取的数据都将丢失**
这就是为何需要关闭管道的未使用读取描述符的原因。

- 管道的一个常见用途是执行shell命令并读取其输出或向其发送一些输入。popen和pclose函数简化了这个任务。
```
#include<stdio.h>
FILE *popen(const char *command,const char *mode);
//成功返回文件流，出错返回NULL
int pclose(FILE *stream);
//成功返回子进程的结束状态，出错返回-1
```
popen函数创建了一个管道，然后创建了一个子进程来执行shell，而shell又创建了一个子进程来执行command字符串。mode参数是一个字符串，它确定调用进程是从管道中读取数据还是将数据写入管道中。
一旦IO结束之后可以使用pclose函数关闭管道并等待子进程的shell终止。（不应该使用fclose函数，因为它不会等待子进程）。

- 由于popen调用返回的文件流指针没有引用一个终端，因此stdio库会对这种文件流应用**块缓冲**。这意味着当将mode的值设置为w来调用popen时，在默认情况下只有当stdio缓冲器被充满或使用pclose关闭了管道之后输出才会被发送到管道另一端的子进程。如果需要确保子进程能够立即从管道中接收数据，那么就需要定期的调用fflush或使用setbuf(fp,NULL)来禁用stdio缓冲。