# 感悟
看了这一章两个想法：
- 书写的是真的好，通俗易懂
- 以前困惑好久的问题终于有点明白了，比如竞赛中在函数里开的数组太大运行会出错，但是放到函数外面就可以；递归次数多了会运行出错；等等

# 总结
- 系统调用getpid()返回调用进程的进程号
```
#include<unistd.h>
pid_t getpid(void);    //返回调用者的进程号
```
- linux内核限制进程号需小于32767，新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用，每当进程号达32767时，内核重置进程号计数器从300开始，重新进行进程号的分配，之所以从300开始而不是从1开始是因为低数值的进程号为系统进程和守护进程长期占用，从1开始遍历只会浪费时间。
- 系统调用getppid(void);返回父进程的进程号
```
#include<unistd.h>
pid_t getppid(void);    //返回该进程的父进程的进程号
```
- 1号进程——init进程，是所有进程的始祖，类似于java中的object类是所有类的父类。如果某父进程终止，则init进程会“收养”其子进程，此时对该子进程调用getppid返回值为1。
关于进程内存布局与虚拟内存的总结我在[我的博客](http://www.chenghuili.cn/2017/12/27/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/)里写的很详细了，感兴趣可以去看下。
- getenv()函数能从进程环境中检索单个值
```
#include<stdlib.h>
char *getenv(const char *name);
```
- putenv()函数向调用进程的环境中添加一个新变量，或者修改一个已经存在的变量值
```
#include<stdlib.h>
int putenv(char *string);    //成功返回0，出错返回负数
```
setenv()函数可以代替putenv向环境中添加一个变量
```
#include<stdlib.h>
int setenv(const char *name,const char *value,int overwrite);    //成功返回0，出错返回-1
若name标识的变量已经存在，且参数3是0，则不改变环境，如果参数3非0，则改变环境
```
- clearenv()函数清除整个环境
```
#define _BSD_SOURCE
#include<stdlib.h>
int clearenv(void);    //成功返回0，出错返回负数
```
- unsetenv()函数从环境中删除由name标识的变量
```
#include<stdlib.h>
int unsetenv(const char *name);    //成功返回0，出错返回-1
```

# 例题描摹
程序6-1：程序变量在进程内存各段中的位置
```
#include<stdio.h>
#include<stdlib.h>
char globBuff[65536];    //未初始化数据段
int primer[] = {1,2,3,4,5,6};    //初始化数据段
static int square(int x){    //为square分配一个栈帧
    int result;    //存于所在square的栈帧中
    result = x*x;
    return result;
}
static void doCalc(int val){    //为函数doCale分配一个栈帧
    if(val < 1000){
        int t;    //存于doCalc函数栈帧中
        t = val*val*val;
        printf("t = %d square fun = %d",t,square(val));
    }
}
int main(int argc,char *argv[]){    //为main分配一个栈帧
    static int key = 9973;    //存于初始化数据段
    static char mbuf[10000000];    //未初始化数据段
    char *p;    //main函数的栈帧中
    p = malloc(1024);    //指针指向堆段
    doCalc(key);
    exit(0);
}
```
程序6-3：显示进程环境
```
extern char **environ;
int main(int argc,char *argv[]){
    char **ep;
    for(ep = environ;*ep != NULL;ep++)
        puts(*ep);
    return 0;
}
```
程序6-4：修改进程环境
```
#define _GNU_SOURCE
#include<stdlib.h>
#include<unistd.h>
extern char ** environ;
int main(int argc,char *argv[]){
    int j;
    char ** ep;
    clearenv();
    for(int j = 1;j<argc;j++){
        if(putenv(argv[j]) != 0)
            exit(1);
    }
    if(setenv("GREET","HELLO WORLD",0) == -1)
        exit(1);
    unsetenv("BYE");
    for(ep = environ;*ep != NULL;ep++)
        puts(*ep);
    exit(0);
}
```
程序6-5：setjmp（）和longjmp（）函数的用法
```

```

# 习题作答
