# 感悟
看了这一章两个想法：
- 书写的是真的好，通俗易懂
- 以前困惑好久的问题终于有点明白了，比如竞赛中在函数里开的数组太大运行会出错，但是放到函数外面就可以；递归次数多了会运行出错；等等

# 总结
- 系统调用getpid()返回调用进程的进程号
```
#include<unistd.h>
pid_t getpid(void);    //返回调用者的进程号
```
- linux内核限制进程号需小于32767，新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用，每当进程号达32767时，内核重置进程号计数器从300开始，重新进行进程号的分配，之所以从300开始而不是从1开始是因为低数值的进程号为系统进程和守护进程长期占用，从1开始遍历只会浪费时间。
- 系统调用getppid(void);返回父进程的进程号
```
#include<unistd.h>
pid_t getppid(void);    //返回该进程的父进程的进程号
```
- 1号进程——init进程，是所有进程的始祖，类似于java中的object类是所有类的父类。如果某父进程终止，则init进程会“收养”其子进程，此时对该子进程调用getppid返回值为1。
关于进程内存布局与虚拟内存的总结我在[我的博客](http://www.chenghuili.cn/2017/12/27/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/)里写的很详细了，感兴趣可以去看下。
- getenv()函数能从进程环境中检索单个值
```
#include<stdlib.h>
char *getenv(const char *name);
```
- putenv()函数向调用进程的环境中添加一个新变量，或者修改一个已经存在的变量值
```
#include<stdlib.h>
int putenv(char *string);    //成功返回0，出错返回负数
```
setenv()函数可以代替putenv向环境中添加一个变量
```
#include<stdlib.h>
int setenv(const char *name,const char *value,int overwrite);    //成功返回0，出错返回-1
若name标识的变量已经存在，且参数3是0，则不改变环境，如果参数3非0，则改变环境
```
- clearenv()函数清除整个环境
```
#define _BSD_SOURCE
#include<stdlib.h>
int clearenv(void);    //成功返回0，出错返回负数
```
- unsetenv()函数从环境中删除由name标识的变量
```
#include<stdlib.h>
int unsetenv(const char *name);    //成功返回0，出错返回-1
```
- setjmp()函数和longjmp()函数提供了非局部跳转功能，类似于跨函数的goto。缺点也类似goto，一般不建议使用。
```
#include<setjmp.h>
int setjmp(jmp_buf env);    //第一调用返回0，第二次返回longjmp设置的值
void longjmp(jmp_buf env,int val);
```

# 例题描摹
程序6-1：程序变量在进程内存各段中的位置
```
#include<stdio.h>
#include<stdlib.h>
char globBuff[65536];    //未初始化数据段
int primer[] = {1,2,3,4,5,6};    //初始化数据段
static int square(int x){    //为square分配一个栈帧
    int result;    //存于所在square的栈帧中
    result = x*x;
    return result;
}
static void doCalc(int val){    //为函数doCale分配一个栈帧
    if(val < 1000){
        int t;    //存于doCalc函数栈帧中
        t = val*val*val;
        printf("t = %d square fun = %d",t,square(val));
    }
}
int main(int argc,char *argv[]){    //为main分配一个栈帧
    static int key = 9973;    //存于初始化数据段
    static char mbuf[10000000];    //未初始化数据段
    char *p;    //main函数的栈帧中
    p = malloc(1024);    //指针指向堆段
    doCalc(key);
    exit(0);
}
```
程序6-3：显示进程环境
```
extern char **environ;
int main(int argc,char *argv[]){
    char **ep;
    for(ep = environ;*ep != NULL;ep++)
        puts(*ep);
    return 0;
}
```
程序6-4：修改进程环境
```
#define _GNU_SOURCE
#include<stdlib.h>
#include<unistd.h>
extern char ** environ;
int main(int argc,char *argv[]){
    int j;
    char ** ep;
    clearenv();
    for(int j = 1;j<argc;j++){
        if(putenv(argv[j]) != 0)
            exit(1);
    }
    if(setenv("GREET","HELLO WORLD",0) == -1)
        exit(1);
    unsetenv("BYE");
    for(ep = environ;*ep != NULL;ep++)
        puts(*ep);
    exit(0);
}
```
程序6-5：setjmp（）和longjmp（）函数的用法
```
#include<setjmp.h>
#include<stdlib.h>
#include<unistd.h>
static jmp_buf env;
static void f2(void){
	longjmp(env,2);
}
static void f1(int argc){
	if(argc == 1)
	    longjmp(env,1);
	f2();
}
int main(int argc,char *argv[]){
	switch(setjmp(env)){
		case 0:
		    printf("Calling f1() after initial setjmp()\n");
		    f1(argc);
		    break;
		case 1:
		    printf("we jumped back from f1()\n");
		    break;
		case 2:
		    printf("we jumped back from f2()\n");
            break;
	}
	exit(0);
}
/*
解释下代码：setjmp（）函数初始调用时返回0，之后调用longjmp（）函数会根据longjmp（）的第二个参数设置env，然后跳转再执行setjmp（），第二次返回值为刚调用longjmp（）设置的env。也就是说，setjmp第一次返回0，第二次返回longjmp设置的env，如果longjmp设置env为0，则其会返回1
*/
```
程序6-6：编译器的优化和longjmp（）函数相互作用的示例
```
#include<stdlib.h>
#include<stdio.h>
#include<setjmp.h>
static jmp_buf env;
static void doJump(int nvar,int rvar,int vvar){
	printf("Inside doJump(): nvar = %d,rvar = %d,vvar = %d\n",nvar,rvar,vvar);
	longjmp(env,1);
}
int main(int argc,char *argv[]){
	int nvar;
	register rvar;
	volatile int vvar;    //防止编译器进行优化重组
	nvar = 111;
	rvar = 222;
	vvar = 333;
	if(setjmp(env) == 0){
		nvar = 777;
		rvar = 888;
		vvar = 999;
		doJump(nvar,rvar,vvar);
	}else{
		printf("after longjmp(): nvar = %d,rvar = %d,vvar = %d\n",nvar,rvar,vvar);
	}
	exit(0);
}
```
# 习题作答
练习6-1
```
程序在磁盘上存储时没有必要为未初始化数据段分配存储空间。可执行文件只需要记录未初始化数据段的起始地址和所需大小，直到运行时再由程序加载器分配该空间
```
