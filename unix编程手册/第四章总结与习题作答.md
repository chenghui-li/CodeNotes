# 感悟（瞎扯）
今天买了tlpi，听说比apue入门好用点，认真拜读啦，文件操作这里还简单点，可以先看tlpi，然后再去啃对应部分的apue，最后把两本书的对应题目一做，美滋滋^_^

这周课设，比较忙，今天先敲了tlpi的题目...

# 总结
**本章对文件打开，关闭，读写，更改偏移指针等系统调用和空洞文件的简单介绍。归纳如下：**
1. 打开文件（open），三个参数分别表示 文件名，打开方式，权限。成功返回文件描述符，失败返回-1 。
打开方式常用选项：
`O_CREAT	//文件不存在则创建`
`O_TRUNC	//截断已有文件，使长度为0，即覆盖`
`O_APPEND	//追加在文件尾，不覆盖`

2. 关闭文件（close）,一个参数，即文件描述符，成功返回0，失败返回-1

3. 读文件（read），三个参数分别表示 文件描述符 存放读取到的内容的缓冲区 最多能读取的字节数，成功则返回实际读取到的字节数，读到文件尾返回0，失败返回-1

4. 写文件（write），三个参数分别表示 文件描述符 存放待写内容的缓冲区 欲写入文件的字节数，成功返回实际写入的字节数，失败返回-1 。因磁盘限制，返回值可能小于第三个参数的值。

5. 改变偏移指针（lseek），三个参数分别表示 文件描述符 偏移字节数 参照基点，成功返回新文件偏移量，失败返回-1

6. 偏移量超过文件尾时继续执行IO操作，此时read会返回0，表示到达文件尾，但是write还可以继续写入，写入的文件距文件结尾处的这段空间称为文件空洞，文件空洞不占用磁盘空间，只有当向空洞位置写入数据才为其分配空间，写入数据前读取该区域将返回0填充的缓冲区。因此，文件名义上的大小比其实际占用的大小要大。

# 例题描摹
4-1
```
/*
功能：将一个文件的内容拷贝到另一个文件
知识点：open,close,read,write函数的使用
概述：
	open(pathname,flags,mode);
	close(fd);
	read(fd,buffer,size);
	write(fd,buffer,size);
*/
#include<unistd.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdio.h>
#define MAX_SIZE 1024
void _error(char *info){
	printf(" error %s\n", info);
	exit(1);
}
int main(int argc,char *argv[]){
	int numRead,numWrite;
	int inputFd,outputFd;
	char buffer[MAX_SIZE];
	if(argc != 3){
		_error("input");
	}
	if(inputFd = open(argv[1],O_RDONLY) == -1)
		_error("open input");
	if ((outputFd = open(argv[2],O_WRONLY|O_CREAT|O_TRUNC,S_IWUSR|S_IRUSR|S_IWGRP|S_IRGRP|S_IWOTH|S_IROTH)) == -1)
	{
		_error("open output");
	}
	while((numRead = read(inputFd,buffer,MAX_SIZE))>0){
		if(write(outputFd,buffer,numRead) != numRead)
			_error("can't write whole buffer");
	}
	if(numRead == -1)
		_error("read");
	if(close(inputFd) == -1)
		_error("close input");
	if(close(outputFd) == -1)
		_error("close output");
	exit(0);

}
```

# 习题作答
**以下题目为本人自己作答与上机验证，如有问题，还望指正**
4-9
我理解到的意思是这样，用户自己判断文件是否存在，如果存在，输入./a.out -a filename 如果不存在输入./a.out filename。所以就按照这个思路写了0.0
```

#include<unistd.h>
#include<string.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdio.h>
#include<stdlib.h>
#define MAX 1024
void errExit(char *err){
	printf("error %s\n",err);
	exit(1);
}
int main(int argc,char *argv[]){
	int inputfd,outputfd;
	int numRead,numWrite;
	char buffer[MAX];
	int ch;
	numRead = numWrite = 0;
	inputfd = outputfd = 0;
	ch = 0;
	memset(buffer,0,sizeof(buffer));		
	if(argc == 2){		//文件不存在
		if((outputfd = open(argv[1],O_WRONLY|O_TRUNC|O_CREAT,S_IWUSR)) == -1)
			errExit("open outputFile");
	}
	else{
		ch = getopt(argc,argv,"a:");		//getopt被这样用有点委屈了0.0
		switch(ch){
			case 'a':
				if((outputfd = open(argv[2],O_WRONLY|O_APPEND,S_IWUSR)) == -1)
					errExit("open outputFile");
				break;
			default :
				errExit("input");
				break;
		}
	}
	while((numRead = read(STDIN_FILENO,buffer,MAX))>0){
		if(write(outputfd,buffer,numRead) != numRead)
			errExit("write file");
		if(write(STDOUT_FILENO,buffer,numRead) != numRead)
			errExit("write stdout");
	}
	if(numRead == -1)
		errExit("read");
	close(outputfd);
exit(0);
}
```
4.10
有思路，应该是根据实际大小和分配大小来卡循环，用stat？现在先不敲了，后面学的6了再更新^_^

未完待续...