# 程序10-2
```
#include "apue.h"
static void sig_usr(int);
int main(int argc,char *argv[]){
	if(signal(SIGUSR1,sig_usr) == SIG_ERR){
		err_sys("can't catch SIGUSR1");
	}
	if(signal(SIGUSR2,sig_usr) == SIG_ERR){
		err_sys("can't catch SIGUSR2");
	}
	for(;;)
		pause();
}
static void sig_usr(int signo){
	if(signo == SIGUSR1){
		printf("received SIGUSR1\n");
	}
	else if(signo == SIGUSR2){
		printf("received SIGUSR2\n");
	}
	else
	    err_dump("received signal %d\n",signo);
}
```

# 程序10-6
```
#include<unistd.h>
#include<signal.h>
#include<stdio.h>
#include<stdlib.h>
#include<sys/wait.h>
static void sig_cld(int);
void perror(const char *str){
	printf("%s\n",str);
	exit(1);
}
int main(int argc,char *argv[]){
	pid_t pid;
	if(signal(SIGCLD,sig_cld) == SIG_ERR){
		perror("signal error");
	}
	if((pid = fork()) <0){
		perror("fork error");
	}else if(pid == 0){
		sleep(2);
		_exit(0);
	}
	pause();
	exit(0);
}
static void sig_cld(int signo){
	pid_t pid;
	int status;
	printf("SIGCLD received\n");
	if(signal(SIGCLD,sig_cld) == SIG_ERR){
		perror("signal error");
	}
	if((pid = wait(&status)) < 0){
		perror("wait error");
	}
	printf("pid = %d\n",pid);
}
```
分析：早期系统执行该代码段会有一些问题，执行结果为重复打印SIGCLD received，直到栈溢出异常终止。若修改为将wait调用放到signal之前即可，即只有其他子进程终止时，内核才会再次产生此种信号。但是经本人上机验证并不是这种输出结果，实际是等待两秒后，打印pid=...，原因是POSIX在信号发生时并没有将信号处理重置为其默认值，也就是说，没有必要在SIGCLD信号处理程序中再为该信号指定一个信号处理程序。
