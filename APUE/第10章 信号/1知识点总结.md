# 概述
- 信号是软件中断，它提供了一种处理异步事件的方法。比如当键入中断键，会通过信号机制停止一个程序，或及早终止管道中的下一个程序。

- 在头文件`signal.h`中，信号名都被定义为正整数常量（信号编号）。不存在编号为0的信号。

- 很多条件下都会产生信号：
1. **用户按某些中断键时。**比如Ctrl-C产生中断信号SIGINT。
2. **硬件异常产生信号**。比如除数为0，无效的内存引用。
3. **进程调用kill函数可将任意信号发送给另一个进程或进程组**。当然前提是接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。
4. **用户使用kill命令将信号发送给其他进程**。常用此命令来终止一个失控的后台进程。
5. **当检测到某种软件条件已经发生，并应将其通知有关进程时也产生信号**。比如SIGURG（在网络连接上传来带外的数据）、SIGPIPE（在管道的读进程已终止后，一个进程写此管道）以及SIGALRM（进程所设置的定时器超时）。

- 在某个信号出现时，可以告诉内核以下列3种方式来处理：
1. **忽略此信号**。大多数信号都可以使用这种方式处理，但有两种信号不能——SIGKILL和SIGSTOP，因为它们向内核和超级用户提供了使进程终止或停止的可靠方法。
2. **捕捉信号**。通知内核在某种信号发生时调用一个用户函数。不能捕捉SIGKILL和SIGSTOP信号。
3. **执行系统默认动作**。对大多数信号的系统默认动作是终止该进程。

- 进程终止时有可能会产生core文件，表示在进程当前工作目录的core文件中复制了该进程的内存映像。大多数UNIX系统调试程序都使用core文件检查进程终止时的状态。在下列条件下不产生core文件：
1. 进程是设置用户ID的，而且当前用户并非程序文件的所有者。
2. 进程是设置组ID的，并且当前用户并非程序文件的组所有者。
3. 用户没有写当前工作目录的权限。
4. 文件已存在，而且用户对该文件设有写权限。
5. 文件太大。

对于前4种原因，更改权限即可解决。第5个原因，则需要在终端输入`ulimit -c unlimited`命令来取消对核心转储文件大小的任何限制。

- 产生信号处理器程序1：signal
```
#include<signal.h>
void (*signal(int signo,void (*func)(int)))(int);
//若成功，返回以前的信号处理配置，若出错，返回SIG_ERR
```
signo参数是信号名。func的值是常量SIG_IGN、常量SIG_DFL或当接到此信号后要调用的函数的地址。如果指定SIG_IGN则忽略此信号（除了SIG_KILL和SIG_STOP），如果指定了SIG_DFL则执行系统默认动作，当指定函数地址时，在信号发生时调用该函数，即捕捉信号，此函数称为*信号处理程序*或*信号捕捉函数*。
解释下这个函数：signal函数原型说明此函数需要两个参数，返回一个函数指针，而该指针指向的函数无返回值。第一个参数signo是一个整型数，第二个参数是函数指针，它所指向的函数无返回值，有一个int型的参数。signal的返回值是一个函数地址，该函数有一个整型参数。
使用typedef可以简化signal函数原型：
```
typedef void sigfunc(int);
sigfunc *signal(int,sigfunc *);
```

- 当执行一个程序时，通常所有信号都被设置为它们的默认动作，除非设置了信号处理器程序。但是如果程序运行了exec，该函数会将原先设置为要捕捉的信号都更改为默认动作（因为信号捕捉函数的地址很可能在新程序中没有意义）。

- signal函数有一个限制：如果不改变信号的处理方式，就没法知道信号的当前处理方式。故其不是很常用。

- 当调用fork创建一个新的子进程时，因为子进程复制了父进程的内存映像，所以信号捕捉函数在子进程中仍有意义。故有结论：**当一个进程调用fork时，其子进程继承父进程的信号处理方式。**

- 如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就被中断不再继续执行。该系统调用返回出错，将errno设置为EINTR。为了支持这种特性，将系统调用分为两类：低速系统调用和其他系统调用。低速系统调用是肯恩会使进程永远阻塞的一类系统调用。