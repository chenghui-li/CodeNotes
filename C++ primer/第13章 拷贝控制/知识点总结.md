# 概述
- 当定义一个类时，可以显式或隐式的指定在此类型的对象拷贝，移动，赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：**拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符和析构函数**。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。这些都称为**拷贝控制操作**。

- 如果一个构造函数的第一个参数是自身类类型的引用（几乎总是const的引用），且任何额外参数都有默认值，则此构造函数是默认构造函数。

- 使用直接初始化实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当使用拷贝初始化时，要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还需要进行类型转换。拷贝初始化一般由拷贝构造函数或移动构造函数来完成。
```
string dos(10,'.');   //直接初始化
string s(dos);        //直接初始化
string s2 = dos;      //拷贝初始化
string s3 = "12345";  //拷贝初始化
string s4 = string(10,'9') //拷贝初始化
```
拷贝初始化不仅在使用=号时发生，下列情况也会发生：
1. 将一个对象作为实参传递给一个非引用类型的形参。
2. 从一个返回类型为非引用类型的函数返回一个对象。
3. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

- 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。这也解释了为什么拷贝构造函数自己的参数是引用类型。如果其参数不是引用类型，则调用将无限循环。

- 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。所以赋值运算符就是一个名为operator=的函数。重载运算符的参数表示运算符的运算对象。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。

- **拷贝赋值运算符接受一个与其所在类相同类型的参数，赋值运算符通常返回一个指向其左侧运算对象的引用：**
```
class Foo{
public:
	Foo& operator=(const Foo&);
}
```

- 析构函数执行与构造函数相反的操作：构造函数初始化对象的非static成员，还可能做一些其他的工作；析构函数释放对象使用的资源，并销毁对象的非static成员。析构函数的名字由波浪号加类名组成，没有返回值，也不接受参数。所以也不能被重载。对于一个给定类，只有唯一一个析构函数。

- 构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，并且按照他们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。通常，析构函数释放对象在生存期分配的所有资源。

- 什么时候调用析构函数？无论何时一个对象被销毁，就会自动调用其析构函数：
1. 变量在离开作用域时被销毁。
2. 当一个对象被销毁时，其成员被销毁。
3. 容器被销毁时，其元素被销毁。
4. 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。
5. 对于临时对象，当创建它的完整表达式结束时被销毁。
注：当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

- 析构函数本身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象的销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的。

- 可以通过将拷贝控制成员定义为=default来显示的要求编译器生成合成的版本：
```
class sales_data{
public:
	sales_data() = default;
	sales_data(const sales_data&) = default;
	sales_data& operator=(const sales_data&);
	~sales_data() = default;
};
sales_data& sales_data::operator(const sales_data&) = default;
```
当在类内使用=default修饰成员的声明时，合成的函数将隐式的声明为内联的。如果不希望合成的成员函数时内联的，应该只对成员的类外定义使用=default，就像上面的拷贝赋值运算符一样。

- 有的时候需要采取某些机制来阻止拷贝或赋值，但是如果仅仅是不声明拷贝构造函数和拷贝赋值运算符是不正确的，因为编译器会自动生成合成版本。可以通过将拷贝构造函数和拷贝赋值运算符声明为删除的函数来达到此目的。表示虽然声明了它们，但是不能以任何方式使用它们。只需要在参数列表后面加上=delete来指出我们希望将它定义成删除的,依次告诉编译器，我们不希望定义这些成员。
```
class nocopy{
	nocopy() = default;
	nocopy(const nocopy&) = delete;			//阻止拷贝
	nocopy& operator=(const nocopy &) = delete;   //阻止赋值
	~nocopy() = default;
};
```

- 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。如果一个类有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数。同样，如果类有const成员，则不能使用合成的拷贝赋值运算符。因为该运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的。引用也是同理，如果将一个新值赋予一个引用成员，则改变的是引用成员的值，引用本身没有修改，所以赋值后，左侧运算对象仍然指向与赋值前一样的对象（同一个），而不会与右侧运算对象指向相同的对象（相同的两个）。

- 试图访问一个声明过但是没有定义的成员将导致一个链接时错误。通过声明但不定义private的拷贝构造函数，可以阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将导致链接时错误。

- 类的拷贝有值行为和指针行为。比如定义一个HasPtr的类，它有两个成员，一个int和一个string指针。通常类直接拷贝内置类型成员。如何拷贝指针决定了像HasPtr这样的类是具有类值行为还是类指针行为。
对于类值行为，HasPtr需要：
1. 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针。
2. 定义一个析构函数来释放string。
3. 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string。
```
class HasPtr{
public:
	HasPtr(const string &s = string()):ps(new string(s)),i(0){ }
	HasPtr(const HasPtr &p):ps(new string(*p.ps)),i(p.i){ };
	HasPtr &operator=(const HasPtr &);
	~HasPtr(delete ps);
private;
	string *ps;
	int i;
};
HasPtr &HasPtr:: operator=(const HasPtr &p){
	auto nowp = new string(*(p.ps));
	delete ps;
	ps = nowp;
	i = p.i;
	return *this;
}
```
赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。而且需要保证，即使将一个对象赋予它自身，也保证正确。异常发生时，左侧对象也应该处于一个有意义的状态。所以一个典型的做法就是**先拷贝右侧运算对象的数据到一个临时对象上，然后释放左侧对象资源，将临时对象赋予左侧对象**。
编写赋值运算符时，需要注意：
1. 如果将一个对象赋予它自身，赋值运算符必须能够正确工作。
2. 大多数赋值运算符组合了析构函数和构造函数的工作。

如果没有第一步的将右侧对象赋值给临时局部对象，直接delete左侧对象资源，当将一个对象赋予自身时，ps与形参p是同一个对象，delete会释放* this和p指向的string。下面试图拷贝\*(p.ps)时会访问到一个指向无效内存的指针，结果未定义。

- 还有一种行为像指针的类，我们需要为这种类定义拷贝构造函数和拷贝赋值运算符，用来拷贝指针成员本身而不是它指向的对象。析构函数不能单方面的释放关联的内存。因为可能有多个对象在共享该内存。
令一个类展现类似指针的行为的最好方法是定义一个引用计数来管理类中的资源，用来记录有多少对象与正在创建的对象共享状态。其一种方法是保存在动态内存中。当创建一个对象时，分配一个新的计数器。当拷贝或赋值对象时，拷贝指向计数器的指针。
```
class HasPtr{
public:
	HasPtr(const string &s = string()):ps(new string(s)),i(0),use(new size_t(1)){ }
	HasPtr(const HasPtr &p):ps(p.ps),i(p.i),use(p.use){ ++*use;}
	HasPtr &operator=(const HasPtr&);
	~HasPtr();
private:
	string *ps;
	int i;
	size_t *use;
};
HasPtr& HasPtr::operator=(const HasPtr &p){
	++p.*use;
	if(--*use == 0){
		delete use;
		delete ps;
	}
	ps = p.ps;
	i = p.i;
	use = p.use;
	return *this;
}
HasPtr::~HasPtr(){
	if(--*use == 0){
		delete ps;
		delete use;
	}
}
```



