# 概述
- 当定义一个类时，可以显式或隐式的指定在此类型的对象拷贝，移动，赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：**拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符和析构函数**。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。这些都称为**拷贝控制操作**。

- 如果一个构造函数的第一个参数是自身类类型的引用（几乎总是const的引用），且任何额外参数都有默认值，则此构造函数是默认构造函数。

- 使用直接初始化实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当使用拷贝初始化时，要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还需要进行类型转换。拷贝初始化一般由拷贝构造函数或移动构造函数来完成。
```
string dos(10,'.');   //直接初始化
string s(dos);        //直接初始化
string s2 = dos;      //拷贝初始化
string s3 = "12345";  //拷贝初始化
string s4 = string(10,'9') //拷贝初始化
```
拷贝初始化不仅在使用=号时发生，下列情况也会发生：
1. 将一个对象作为实参传递给一个非引用类型的形参。
2. 从一个返回类型为非引用类型的函数返回一个对象。
3. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

- 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。这也解释了为什么拷贝构造函数自己的参数是引用类型。如果其参数不是引用类型，则调用将无限循环。

- 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。所以赋值运算符就是一个名为operator=的函数。重载运算符的参数表示运算符的运算对象。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数。

- **拷贝赋值运算符接受一个与其所在类相同类型的参数，赋值运算符通常返回一个指向其左侧运算对象的引用：**
```
class Foo{
public:
	Foo& operator=(const Foo&);
}
```

- 析构函数执行与构造函数相反的操作：构造函数初始化对象的非static成员，还可能做一些其他的工作；析构函数释放对象使用的资源，并销毁对象的非static成员。析构函数的名字由波浪号加类名组成，没有返回值，也不接受参数。所以也不能被重载。对于一个给定类，只有唯一一个析构函数。

- 构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，并且按照他们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。通常，析构函数释放对象在生存期分配的所有资源。

- 什么时候调用析构函数？无论何时一个对象被销毁，就会自动调用其析构函数：
1. 变量在离开作用域时被销毁。
2. 当一个对象被销毁时，其成员被销毁。
3. 容器被销毁时，其元素被销毁。
4. 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。
5. 对于临时对象，当创建它的完整表达式结束时被销毁。
注：当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

- 析构函数本身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象的销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的。

- 可以通过将拷贝控制成员定义为=default来显示的要求编译器生成合成的版本：
```
class sales_data{
public:
	sales_data() = default;
	sales_data(const sales_data&) = default;
	sales_data& operator=(const sales_data&);
	~sales_data() = default;
};
sales_data& sales_data::operator(const sales_data&) = default;
```
当在类内使用=default修饰成员的声明时，合成的函数将隐式的声明为内联的。如果不希望合成的成员函数时内联的，应该只对成员的类外定义使用=default，就像上面的拷贝赋值运算符一样。

- 有的时候需要采取某些机制来阻止拷贝或赋值，但是如果仅仅是不声明拷贝构造函数和拷贝赋值运算符是不正确的，因为编译器会自动生成合成版本。可以通过将拷贝构造函数和拷贝赋值运算符声明为删除的函数来达到此目的。表示虽然声明了它们，但是不能以任何方式使用它们。只需要在参数列表后面加上=delete来指出我们希望将它定义成删除的,依次告诉编译器，我们不希望定义这些成员。
```
class nocopy{
	nocopy() = default;
	nocopy(const nocopy&) = delete;			//阻止拷贝
	nocopy& operator=(const nocopy &) = delete;   //阻止赋值
	~nocopy() = default;
};
```
