# 概述
- 全局对象在程序启动时分配，在程序结束时销毁。对于自动局部对象，在进入其定义所在的程序块时被创建，离开块时被销毁。局部static对象在第一次使用时创建，在程序结束时销毁。动态分配的对象的生存期与它们在哪里创建是无关的，它存在于堆中，只有当显式的被释放时，这些对象才会被销毁。为了更安全的使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动的释放它。

- 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用前分配，在程序结束时销毁。

- 在C++中，动态内存的管理是通过一对运算符来完成的，**new**在动态内存（堆）中为对象分配空间并返回一个指向该对象的指针，可以选择对象进行初始化；**delete**接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

- 智能指针的行为类似常规指针，重要的区别在于它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式；**shared_ptr**允许多个指针指向同一个对象；**unique_ptr**则独占所指向的对象。最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。
要用make_shared时必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名后跟一个尖括号，在其中给出类型。
```
//指向一个值为43的int的shared_ptr
shared_ptr<int> p = make_shared<int>(43);
//指向一个值为“9999999999”的string
shared_ptr<string> p2 = make_shared<string>(10,'9');
//指向一个值初始化的int，即值为0
shared_ptr<int> p3 = make_shared<int>();
```

- 当进行拷贝和赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。
```
auto p = make_shared<int>(42);   //p指向的对象只有一个p一个引用者
auto q(p);    //p和q指向相同的对象，此对象有两个引用者
```
可以认为每个shared_ptr都有一个关联的计数器，通常称为**引用计数**，无论何时拷贝一个shared_ptr，计数器都会递增，例如：
1. 当用一个shared_ptr初始化另一个shared_ptr。
2. 将它作为参数传递给一个函数。
3. 作为函数的返回值
当给一个shared_ptr赋予一个新值或是shared_ptr被销毁，计数器就会递减。**一旦一个shared_ptr的计数器变为0，他就会自动释放自己所管理的对象**。
```
auto r = make_shared_ptr<int>(42);    //r指向的int只有一个引用者
r = q;   
//给r赋值，令其指向另一个地址，
//递增q指向的对象的引用计数
//递减r原来指向的引用计数
//r原来的引用计数变为0，没有引用者，会自动释放
```

- 