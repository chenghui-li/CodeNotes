# 概要
- 除去布尔型和扩展的字符型之外，其他整型可以划分为带符号的和无符号的两种，unsigned int可以缩写为unsigned。
- 与其他整型不同，字符型被划分为三种：char，signed char，unsigned char。需要注意：类型char和类型
signed char并不一样。尽管字符型有三种，但是字符型的表现形式只有两种：带符号和无符号。
- 无符号类型中的所有比特都用来存储值。比如8比特的unsigned char可以表示0至255（2^8-1）区间内的值。带符号类型中有一位用来表示正负。比如8比特的char可以表示-128（-2^7）至127（2^7-1）区间内的值。

```
unsigned char c = -1;    //假设char占8比特，c的值为255
signed char c2 = 256;    //假设char占8比特，c2的值是未定义的
```
1. 当赋给无符号类型一个超过它表示范围的值时，**结果是初始值对无符号类型表示数值总数取模后的余数**，比如第一行中的unsigned char可以表示0——255区间内的值，如果赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数
2. 当赋给带符号类型一个超过它表示范围的值时，**结果是未定义的**。此时程序可能正常工作，可能崩溃，也可能生成垃圾数据。

- C++中，初始化和赋值是两个完全不同的操作。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
- 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。
- 无论是初始化对象还是某些时候为对象赋新值，都可以使用一组由花括号括起来的初始值(C++11新标准)。比如，要想定义一个名为units_sold的int变量并初始化为0，可以这样写：
```
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

- 变量的**声明**即使得名字为程序所知，一个文件如果想使用别处定义的名字，则必须包含对那个名字的声明，声明规定了变量的类型和名字。**定义**负责创建与名字关联的实体。定义还申请存储空间，也可能会为变量赋一个初始值。变量能且只能被定义一次，但可以被声明多次。如果想声明一个变量而非定义它，就在变量名前面添加关键字extern，而且不要显示的初始化变量。
```
extern int i;    //声明i而非定义i
int j;    //声明并定义j
```
- **引用**（C++特有，C没有）并非对象，它只是一个已经存在的对象的另一个名字，在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。
- 指针与引用类似，实现了对其他对象的间接访问。因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。指针也和引用有些异处：
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义时赋初值。
- 空指针不指向任何对象，在使用一个指针之前可以首先检查它是否为空。有几种生成空指针的方法：
```
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```
在C++11新标准下，**最好使用nullptr，同时避免使用NULL**
- 对于两个类型相同的指针，可以用相等操作符（==）或不相等操作符（！=）来比较，如果两个指针存放的地址值相同（都为空、都指向同一个对象、都指向同一个对象的下一个地址），则它们相等；反之不相等。
- 对于复杂的声明语句，从左向右阅读更容易理解其表达的意思：
```
int i = 42;
int *p;
int *&r = p;    //指针的引用
r = &i;    //给指针的引用赋值即对指针赋值：令p指向i
*r = 0;    //解引用r得到i，即p指向的对象，将i的值改为0
```
离r最近的是&，说明r是一个引用，其次是\*，说明r是一个对指针的引用，再者是int，说明r引用一个int指针
- C++11新标准规定，允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。尽管指针和引用都能定义成constexpr，但它们的初始值受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储在某个固定地址中的对象。函数体内定义的变量一般来说并非存放在固定地址中（位于栈帧中），因此constexpr指针不能指向这样的变量。相反的，定义于所有函数之外的对象其地址固定不变（位于已初始化数据段），能用来初始化constexpr指针。

- 类型别名是一个名字，它是某种类型的同义词。有两种方法可用于定义类型别名。传统方法是使用**typedef**，
```
typedef double wages;    //wages是double的同义词
typedef wages base,*p;   //base是double的同义词，p是double *的同义词
```
还有一种方法是使用别名声明来定义类型的别名：
`using SI = Sales_item    // SI是Sales_item的同义词`
这种方法使用关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是**把等号左侧的名字规定成等号右侧的类型的别名**
```
typedef char *pstring;
const pstring cstr = 0;    //cstr是指向char的常量指针
const pstring *ps;         //ps是一个指针，它的对象是指向char的常量指针
```
上述两条声明语句的基本数据类型都是const pstring，const是对给定类型的修饰。pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针，而非指向常量字符的指针。切不可将其简单的替换进行理解，比如：
`const char *cstr = 0;    //这是对const pstring cstr的错误理解`
声明语句中用到pstring时，其基本数据类型是指针。可是用char \*重写了声明语句后，数据类型就变成了char，\*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明的含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

- C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所述的类型。和原来那些只对应一种特定类型的说明符不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：
`auto item = val1 + val2;    //item初始化为val1和val2相加的结果`

使用auto也能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：
```
auto i = 0,*p = &i;    //正确，i是整数，p是整型指针
auto sz = 0,pi = 3.14; //错误，sz和pi的类型不一致
```

- 使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：
```
int i = 0,&r = i;
auto a = r;    //a是一个整数，r是i的别名，i是一个整数
```

- auto一般会忽视顶层const，但是会保存底层const，比如当初始值是一个指向常量的指针时：
```
const int ci = i,&cr = ci;
auto b = ci;    //b是一个整数（ci的顶层const特性被忽略掉了）
auto c = cr；   //c是一个整数（cr是ci的别名，ci本身是一个顶层const）
auto d = &i;    //d是一个整型指针（整数的地址就是指向整数的指针）
auto e = &ci;   //e是一个指向常量整数的指针（对常量对象取地址是一种底层cosnt）
```
如果希望推断出auto类型是一个顶层const，需要明确指出：
`cosnt auto f = ci;`
还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：
```
auto &g = ci;    //g是一个常量引用，绑定到ci
auto &h = 42;    //错误，不能将一个非常量引用绑定到字面值
const auto &j = 42;    //正确，可以为常量引用绑定字面值
```
