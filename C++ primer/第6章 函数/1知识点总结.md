# 概述
- 实参是形参的初始值，第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。

- 函数的返回类型不能是数组类型或函数类型，但是可以是指向数组的指针和指向函数的指针。

- 在C++语言中，名字有作用域，对象有生命周期
*名字的作用域是程序文本的一部分，名字在其中可见*
*对象的生命周期是程序执行过程中该对象存在的一段时间*

- 函数是一个语句块。块构成一个新的作用域，可以在其中定义变量。形参和函数体内部定义的变量统称为局部变量，仅在函数内部可见，同时局部变量还会隐藏在外层作用域中同名的其他所用声明。

- 在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会被销毁。局部变量的生命周期依赖于定义的方式。

- 对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

- 形参是一种自动对象，函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。

- 对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；如果变量定义本身不含初始值，执行默认初始化。也就是说，**内置类型的未初始化局部变量将产生未定义的值。**

- **局部静态对象**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显示的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0.

- 函数的名字必须在使用之前声明，类似于变量，函数只能定义一次，但可以声明多次。

- 函数的声明与函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。因为函数的声明不包含函数体，所以无须形参的名字，使用中经常在声明中省略形参名字，但是为了阅读方便，写上更好。

- 函数的三要素（**返回类型，函数名，形参类型**）描述了函数的接口，说明了调用该函数所需的全部信息。函数的声明也称作**函数原型**。

- 建议变量在头文件中声明，在源文件中定义，类似的，函数也应该在头文件中声明，在源文件中定义。这样做的好处是：如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。

- 形参的类型决定了形参和实参的交互方式。如果形参是引用类型，它将绑定到对应的实参上；否则将实参的值拷贝后赋给形参。当形参是引用类型时，我们说它对应的实参被**引用传递**或者函数被**传引用调用**。也就是说，形参是对应实参的别名。

- 当实参的类型是比较大的类类型时，此时传参应该避免拷贝，应使用引用形参访问。引用形参还可以用于函数返回额外的信息。当函数无须修改引用形参的值时最好将其声明为常量引用。

- 当使用实参初始化形参时会忽略掉形参的顶层const。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的：
`void fcn(const int i){...}  //fcn能够读取i，但是不能修改i`
调用fcn函数时，实参既可以是const int，也可以是int，这就是const形参的一个好处，如果i声明为非const的形参，则对应的实参只能是int不能是const int。

- 当需要以数组作为形参时，有两点需要考虑：
1. 数组不能拷贝，所以不能以值传递的方式使用数组参数。
2. 因为数组会被转换成指针，所以当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
以下三个函数是等价的：
```
void print(const int *);
void print(const int []);
void print(const int [10]);    //这里的维度表示期望数组含有多少个元素，实际不一定
```
每个函数的形参都是const int * 类型。当编译器处理对print函数的调用时，只检查传入的参数是否是const int * 类型：
```
int i = 0;
int j[2] = {1,2};
print(&i);    //正确，&i的类型是int *类型
print(j);    //正确，j转换成int *并指向j[0]
```

- 当传递给函数的实参是一个数组时，则实参自动的转换为指向数组首元素的指针，数组大小对函数没有影响，因此，数组的大小对于函数来说是未知的，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术：
**使用标记指定数组长度**
此方法要求数组本身包含一个结束标记，一个典型示例就是C风格字符串存储在字符数组中，在最后一个字符后面跟着一个'\0'。函数在处理C风格字符串时遇到空字符就停止。
```
void print(const char *cp){
	if(cp){    //若cp不是一个空指针
		while(*cp)    //只要指针所指的字符不是空字符
		    cout<<*cp++;    //输出当前字符并将指针向前移动一个位置
	}
}
```
这种方法适用于有明显结束标记的数组，比如int类型的数组就不适用了。

**使用标准库规范**
该方法是传递指向数组首元素和尾后元素的指针,需要使用begin和end库函数：
```
void print(const int *beg,const int *end){
	//输出beg到end之间（不含end）的所有元素
	while(beg != end){
		cout<<*beg++<<endl;
	}
}
```
注意：形参的const作用的是\*beg和\*end，而不是beg和end，也就是说const的功能在此为不许修改数组的元素。所以beg++是可以的。
为了调用这个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一个位置。
```
int j[2] = {1,2};
print(begin(j),end(j));
```

**显示传递一个表示数组大小的形参**
该方法是专门定义一个表示数组大小的形参。
```
void print(const int ia[],size_t size){
	//const int ia[]等价于const int *ia,size表示数组大小
	for(size_t i = 0;i!=size;i++){
		cout<<ia[i]<<endl;
	}
}
```
调用print函数时必须传入这个表示数组大小的值
```
int j[] = {0,1};
print(j,end(j) - begin(j));
```
只要传递给函数的size值不大于数组的实际大小，函数就是安全的。

- C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时引用形参绑定到对应的实参上，也就是绑定到数组上：
```
void print(int (&arr)[10]){
	for(auto elem:arr){
		cout<<elem<<endl;
	}
}
```
此时只能将函数作用于大小为10的数组。

- 在C++语言中实际上没有真正的多维数组，所谓多维数组其实是数组的数组。当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维以及后面所有维度的大小都是数组类型的一部分，不能省略：
`void print(int (*matrix)[10]，int rowsize)    //matirx指向数组的首元素，该数组的元素是由10个整数构成的数组`
等价于：
`void print(int matrix[][10],int rowsize)`

- 有两种方法可以用于编写处理不同数量实参的函数：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是可变参数模板。C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。

- 如果实参数量未知但是类型都相同，可以使用initializer_list类型的形参。它是一种标准库类型，用于表示某种特定类型的值的数组，其定义在同名的头文件中，和vector一样，也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型：
`initializer_list<string> ls;`
和vector不一样的是，initializer_list对象中的元素永远是常量值，也就是说，我们无法改变initializer_list对象中元素的值。如果向initializer_list中传递一个值的序列，必须把序列放到一对花括号内。

- 省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎两种：
```
void foo(parm_list,...);
void foo(...);
```

- 当函数返回时，如果返回的是一个值，则返回值将被拷贝到调用点；
```
string make_plural(size_t ctr,const string &word,const string &ending){
	return (ctr>1) ? word + ending : word;
}
```
返回类型是string，因此，该函数将返回word的一个副本或者一个未命名的临时string对象，该对象的内容是word和ending的和。

如果函数返回一个引用，则该引用仅是它所引对象的一个别名。
```
const string &shorterString(const string &s1,const string &s2){
	return s1.size() < s2.size() ? s1 : s2;
}
```
其中形参和返回类型都是const string的引用，不管是调用函数还是返回结果都不会真正拷贝string对象。

- **不要返回局部对象的引用或指针**！！！函数完成后，它所占用的存储空间也将随之释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域，指针将指向一个不存在的对象：
```
const string &manip(){
	string ret;
	if(!ret.empty())
	    return ret;    //错误，返回局部对象的引用
	else
	    return "empty";    //错误，“empty”是一个局部临时变量
}
```
该例中的两条return语句都将返回未定义的值，也就是说，试图使用manip函数的返回值将引发未定义的行为。第一条return语句返回了局部对象的引用。第二条return语句中，字符串字面值转换成一个局部临时string对象，对于manip来说，该对象和ret都是局部的。当函数结束时，临时对象占用的空间将随之释放掉，所以两条return语句都指向了不再可用的内存空间。

- 调用一个返回引用的函数得到左值，其他返回类型得到右值。如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果作为访问结果对象的成员。

- 因为数组不能被拷贝，所以函数不能返回数组。不过可以返回数组的指针或引用。可以使用类型别名来简化这种函数的定义：
```
typedef int arrT[10];    //arrT是一个类型别名，它表示的类型是含有10个整数的数组
using arrT = int[10];    //arrT的等价声明
arrT* func(int i);       //func返回一个指向含有10个整数的数组的指针
```
也可以不使用类型别名，但是必须牢记被定义的名字后面数组的维度：
```
int arr[10];    //arr是一个含有10个整数的数组
int *p1[10];    //p1是一个含有10个指针的数组
int (*p2)[10] = &arr;    //p2是一个指针，指向含有10个整数的数组
```
和这些声明一样，如果想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后，然而，函数的形参列表也跟在函数名字之后且**形参列表应该先于数组的维度**。
`type (*function(parameter_list))[dimension]`
type表示元素的类型，dimension表示数组的大小。(\*function(parameter_list))两端的括号必须存在，如果没有括号，函数的返回类型将是指针的数组。例如：
`int (*func(int i))[10];`
可以由内而外来理解该声明的含义：
1. `func(int i)`表示调用func函数时需要一个int类型的实参。
2. `(*func(int i))`意味着可以对函数的调用结果执行解引用操作。
3. `(*func(int i))[10]`表示解引用func的调用将得到一个大小是10的数组。
4. `int (*func(int i))[10]`表示数组中的元素是int类型

- 对于函数的返回值类型是数组的指针或引用的情况，可以使用**尾置返回类型**来表示。尾置返回类型跟在形参列表后并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，在本应该出现返回类型的地方放置一个auto：
`auto func(int i) -> int(*) [10];`
func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组。

- 如果同一作用域内的几个函数名字相同但形参列表不同，称之为**重载函数**。对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。

- 一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来；如果形参是某种类型的指针或引用，则通过则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。因为const不能转换成其他类型，所以只能把cosnt对象传递给const形参。非常量对象可以传递给常量形参，但是，**当传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本**。

- 对于上述的shorterString的例子，如果两个实参都是普通的string，函数的返回值仍是const string的引用，这时需要一种函数，当实参是非常量时，返回的值也是非常量，使用const_cast可以做到：
```
string &shorterString(string &s1,string &s2){
	auto r = shorterString(const_cast<const string &>(s1),const_cast<const string &>(s2));
	return const_cast<string &>(r);
}
```
首先将它的非常量实参强制转换成对const的引用，然后调用shorterString的const版本。返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参（r）上，因此，可以再将其转换回一个普通的string &，这显然是安全的。

- 如果在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同作用域中无法重载函数名：
```
string read();
void print(const string &);
void print(double);
void fooBar(int ival){
	bool read = false;    //新作用域：隐藏了外层的read
	string s = read();    //错误：read现在是一个布尔值
	void print(int);    //不好的习惯：不应该在局部作用域中声明函数
	print("value");    //错误，print(const string &)被隐藏
	print(ival);       //正确，当前print(int)可见
	print(3.14);       //正确，调用print(int)
}
```
在C++语言中，名字查找发生在类型检测之前。

- 某些函数有这样一些形参，在函数的很多次调用中它们都被赋予一个相同的值，把这个反复出现的值称为**默认实参**。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。但是一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。在设计含有默认实参的函数时，应合理设置形参的顺序，让不怎么使用默认值的形参出现在前面，让经常使用默认值得形参出现在后面。在调用含有默认实参的函数时，实参应从左向右赋值，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。
```
typedef string::size_type sz;
string screen(sz ht = 24,sz wid = 80,char backgrnd = ' ');
string window;
window = screen();    //等价于screen(24,80,' ');
window = screen(66);  //等价于screen(66,80,' ');
window = screen(66,256);  //screen(66,256,' ');
window = screen(66,256,'#');
window = screen(,,'?');  //错误，只能省略尾部的实参   
```
局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：
```
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(),sz = wd,char = def);
string window = screen();    //调用screen(ht(),80,' ');

void f2(){
	def = '*';    //改变默认实参的值
	sz wd = 100;  //隐藏了外层定义的wd，但是没有改变默认实参
	window = screen();   //调用screen(ht(),80,'*');
}
```

- 调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。如果把函数声明为内联函数可以避免函数调用的开销，在调用点将内联的展开，从而消除程序的运行时开销。只需要在函数的返回类型前面加上关键字inline就可以将它声明成内联函数。但是内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。

- 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关：
`bool lengthCompare(const string &,const string &);  //比较两个string对象的长度`
该函数的类型是bool(const string &,const syring &)。**要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。**
`bool (*pf)(const string &,const string &);`
从声明的名字开始观察，pf前面有个* ，所以pf是指针；右侧是形参列表，表示pf指向的是函数；再观察左侧，发现函数的返回类型是布尔
类型。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。
注意：pf两端的括号不能少，否则pf是一个返回值为bool指针的函数。
当把函数名作为一个值使用时，该函数自动的转换成指针。例如，可以这样将lengthCompare的地址赋给pf：
```
pf = lengthComplare;    //pf指向名为lengthComplare的函数
pf = &lengthComplare;   //等价的赋值语句：取地址符是可选的
```
可以直接使用指向函数的指针调用该函数，无须提前解引用指针：
```
bool b1 = pf("hello","goodbye");    //调用lengthComplare函数
bool b2 = (*pf)("hello","goodbye"); //等价调用
bool b3 = lengthCompare("hello","goodbye"); //等价调用
```
在指向不同函数类型的指针间不存在转换规则

- 可以让一个函数返回指向函数的指针，最简单的方法是使用别名：
```
using F = int(int *,int);   //F是函数类型，不是指针
using PF = int(*)(int *,int);   //PF是指针类型
```
与形参类型不同的是，返回类型不会自动的转换成指针。必须显示的将返回类型指定为指针：
```
PF f1(int);    //正确，PF是指向函数的指针，f1返回指向函数的指针
F f1(int);     //错误，F是函数类型，f1不能返回一个函数
F *f1(int);    //正确，显示的指定返回类型是指向函数的指针
```
也可以不用类型别名直接声明f1：
`int (*f1(int))(int *,int)`
