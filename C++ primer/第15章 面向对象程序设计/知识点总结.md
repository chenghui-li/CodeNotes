# 概述
- 面向对象程序设计的核心思想是：**数据抽象，继承和动态绑定**。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似的关系建模；使用动态绑定可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

- 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。在C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为**虚函数**。虚函数的声明形式是：在函数的最前面（返回类型前）加上关键字**virtual**。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
```
class Quote{
public:
	string isbn() const;
	virtual double net_price(size_t n) const;
}
```
- 派生类必须通过使用类派生列表明确指出它是从哪个（哪些）基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前可以有访问说明符。访问说明符的作用是控制派生类从基类继承而来的成员对派生类用户是否可见。如果一个派生是公有的，则基类的公有成员也是派生类的接口的组成部分。此外，还可以将公有派生类型的对象绑定到基类的引用或指针上。
```
class Bulk_quote : public Quote{
public:
	double net_price(size_t n)const override;
}
```

- 派生类必须在其内部对所以重新定义的虚函数进行声明。派生类可以在这些函数前加上virtual关键字，但不是必须这样做。override是C++11新标准规定，用来显式的注明使用哪个成员函数改下基类的虚函数。

- 使用动态绑定可以使用一段代码处理基类和派生类的对象。
```
double print_total(ostream &os,const Quote &item,size_t n){
	double ret = item.net_price(n);
	os<<"ISBN: "<<item.isbn()<<"sold: "<<n<<" total due: "<<ret<<endl;
}
```
因为函数print_total的形参是基类Quote的一个引用，所以，既可以使用基类的对象调用该函数，也可以使用派生类的对象调用该函数。又因为是使用引用类型调用net_price的，所以，实际传入print_total的对象类型将决定到底执行net_price的哪个版本。
```
//basic是基类Quote的一个对象，bulk是派生类的一个对象
print_total(cout,basic,20);
print_total(cout,bulk,20)
```
因为在上述过程中函数的运行版本由实参决定，即在运行时决定函数的版本，所以动态绑定又称为运行时绑定。

- **在C++中，当使用基类的引用或指针调用一个虚函数时，将发生动态绑定。**作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不进行任何操作也是如此。

- 派生类经常但不总是覆盖它继承的虚函数。如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他普通成员函数，派生类会直接继承其在基类中定义的版本。

- 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样子的子对象也有多个。

- 因为在派生类对象中含有与其基类对应的组成部分，所以可以把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换称为派生类到基类的转换 
```
Quote item;    //基类对象
Bulk_quote bulk;    //派生类对象
Quote *p = &item;    ／／p指向基类对象
p = &bulk;   ／／p指向bulk的基类部分
Quote &r = bulk;   ／／r绑定到bulk的基类部分
```
- 尽管在派生类对象中含有从基类继承而来的成员，但是派生类不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。类似于初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数。
```
Bulk_quote(const string &book,double p,size_t qty,double
 disc):Quote(book,p),minqty(qty),discount(disc){ }
```
首先初始化基类成员，然后按照声明顺序依次初始化派生类的成员。

-  如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。而且静态成员遵循通用的访问控制原则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则既可以通过基类使用它，也能通过派生类使用它。
```
class Base{
public:
    static void statmem();
};
class Derived : public Base{
    void f(const Derived &);
private:
	size_t min_qty = 0;
	double discount = 0.0;
};
void Derived::f(const Derived &obj){
    Base::statmem();    //正确，Base定义了statmem
    Derived::statmem();  //正确，Derived继承自Base
    obj.statmem();    //通过派生类对象访问 
    statmem();    //通过this对象访问 
}
```
- 在一个继承链中，如果类A派生B，B派生C，则称B是C的直接基类，A是B的直接基类，A是C的间接基类，因为派生类会包含直接基类的所有成员，该类又包含它的基类的所有成员，以此类推，结果就是：**最终的派生类将包含其直接基类的子对象和每个间接基类的子对象**

- 有时不希望一个类被其他类继承，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C ++11规定了一种防止继承的方法，××在类名后面跟一个关键字final××

- 如果想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则，在继承体系中，可以将基类的指针或引用绑定到派生类对象上，这也就意味着：当使用基类的引用或指针时，实际上并不清楚该引用或指针所绑定的对象的类型。可能是派生类对象，也可能是基类对象。

- 一个表达式有静态类型，也有动态类型。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才知道。就像print-total函数，当实参是bulk-quote时，item的静态类型与动态类型不一致。××如果表达式既不是引用也不是指针，则它的动态类型与静态类型永远一致。××

- 之所以存在派生类向基类的类型转换，是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在，如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换。
```
Quote base;
Bulk_quote* bulkP = &base;    //错误，不能将基类转换成派生类
Bulk_quote& bulkRef = base;   //错误，不能将基类转换成派生类
```
如果这是合法的，那么bulkP和bulkref就可以访问base中本不存在的成员。
即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换：
```
Bulk_quote bulk;
Quote *itemP = &bulk;    // 正确，itemp的动态类型是Bulk-quote
Bulk_quote *bulkP = itemP;   // 错误，不能将基类转换成派生类
```	
- 编译器在编译时无法确定某个特定的转换是不是合法的，因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果基类中含有一个或多个虚函数，可以使用dynamic_cast请求一个类型转换，该转换的安全检查在运行时执行，同样，如果已知某个基类向派生类转换是安全的，这可以使用static_cast来强制覆盖掉编译器的转换检查工作。

- 派生类向基类的转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。在基类的拷贝构造函数和拷贝赋值运算符上，当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。

- 虚函数必须有定义，这是因为基类的引用或指针在调用虚函数时会发生动态绑定，只有当运行时才可以知道调用了哪个版本的虚函数。类似的，通过对象进行的函数调用或者对非虚函数的调用在编译时进行绑定。对象的类型是确定不变的，无论如何都不可能令对象的动态类型与静态类型不一致。**当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该引用。**

- 一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被覆盖的基类函数完全一致。返回类型与基类函数相匹配（如果基类虚函数返回一个指向基类本身的引用或指针，则派生类中类似的返回指向派生类本身的引用或指针）。

- 派生类中有与基类虚函数名相同但是形参类型不同或返回值不同的函数，这也是合法行为，只不过这是两个完全独立的函数。这有可能是书写时形参写错了，可以为了让编译器帮助查找此类错误，可以在派生类中要覆盖的虚函数声明后面加上override关键字
```
struct B{
	virtual void f1(int) const;
	virtual void f2() const;
	f3(int);
};
struct D:B{
	void f1(int)const override;    //正确
	void f2(int)cosnt override;    //错误，形参不匹配
	void f3(int) override;         //错误，f3不是虚函数
	void f4() override;            //错误，基类没有f4函数
}
```

- 还可以把函数指定为final，如果把一个函数定义成final，则任何尝试覆盖它的操作都将引发错误。final指定的类不允许被继承（前面说过）。

- 虚函数也可以有默认实参。如果某次函数调用使用了默认实参，则该**实参值由本次调用的静态类型决定**。比如说当用基类的引用或指针调用虚函数时，不管最后使用的是派生类虚函数还是基类虚函数，使用的虚函数的默认实参都是基类的虚函数的默认实参。

- 如果派生类的虚函数需要调用基类的虚函数，必须使用作用域运算符，否则默认调用派生类的虚函数，将导致无限递归。

- 通过在函数体的位置（在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处。可以为纯虚函数提供定义，不过函数体必须定义在类的外部。含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，后续的其他类可以覆盖该接口。**不能创建一个抽象基类的对象。**

- 一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。可以说，protected拥有与public和public公有的属性：
1. 和私有成员类似，受保护的成员对于类的用户来说是不可能访问的。
2. 和公有成员类似，受保护的成员对于派生类来说是可以访问的。
3. **派生类的成员或友元只能通过派生类的对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有访问权限**。举个例子：
```
class Base{
protected:
	int prot_mem;
};
class Sneaky : public Base{
	friend void clobber(Sneaky&);    //能访问Sneaky::prot_mem
	friend void clobber(Base&);      //不能访问Base::prot_mem
	int j;    //默认是private的
};
void clobber(Sneaky &s){
	//正确，clobber能访问Sneaky对象的private和protected成员
	s.j = s.prot_mem = 0;
}
void clobber(Base &b){
	//错误，clobber不能访问Base对象的protected成员
	b.prot_mem = 0;
}
```
其实也很好理解，clobber并不是Base的友元，当然不能访问Base的protected成员。

- 派生类访问说明符对于派生类的成员（以及友元）能否访问其直接基类的成员没有什么影响。对基类成员的访问权限只与基类中的访问说明符有关。派生访问说明符的目的是控制**派生类用户（以及派生类的派生类）**对于基类成员的访问权限。

> 类的设计和受保护成员：
不考虑继承的话，可以认为一个类有两种不同的用户：普通用户和类的实现者。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有成员；实现者则负责编写类的成员和友元代码，成员和友元既可以访问类的公有部分，也可以访问类的私有部分。
如果再考虑继承的话，就出现第三种用户：派生类。基类把它希望派生类能访问的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍不能访问私有成员。

- 不能继承友元关系，每个类负责控制各自成员的访问权限。

- 使用using声明语句可以改变成员的可访问性。比如派生类**私有继承**自基类，在派生类的public下用using声明基类的公有或受保护成员。则派生类可以访问基类的该成员。如果using声明语句位于protected下，则该名字对于成员，友元和派生类都是可访问的。

- **struct和class的唯一差别就是默认成员访问说明符及默认派生访问说明符**。struct的默认成员访问说明符和默认派生访问说明符是public，class的默认成员访问说明符和默认派生访问说明符是private。

- 每个类定义自己的作用域，在这个作用域内可以定义类的成员。当存在继承关系时，派生类的作用域嵌套在基类的作用域中。如果一个名字在派生类中无法解析，则编译器会继续在外层的基类作用域中寻找该名字的定义。

- 一个对象，引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型与动态类型不一致。

- 派生类的成员将隐藏同名的基类成员。所以除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

- 当delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与动态类型不同的情况。比如Quote\*类型的指针，该指针有可能指向Bulk_quote类型的对象，此时编译器应该清楚它应该执行的是Bulk_quote的析构函数。和其他函数一样，通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。和其他函数一样，虚析构函数的虚属性也会被继承。因此，无论无论Quote的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。总之**只要基类的析构函数是虚函数，就能确保当delete基类指针时将运行正确的析构函数版本。**
```
Quote *item = new Quote;
delete item;    //调用Quote的析构函数 
item = new Bulk_quote;
delete item;    //调用Bulk_quote的析构函数
```
**如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将导致未定义的行为**。

- 如果一个类定义了析构函数，即使是使用=default使用合成的默认析构函数，编译器都不会为这个类合成移动操作。

- 基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。除此之外还会使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。此操作的前提是相应的成员应该可访问并且不是一个被删除的函数。

- 对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁该派生类的直接基类，该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

- 在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。

- 和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。对象的销毁顺序与创建对象相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推。

- 当为派生类定义拷贝或移动构造函数时，通常使用对应的基类构造函数初始化对象的基类部分：
```
class Base{...};
class D: public Base{
public:
	D(const D &d):Base(d){}    //拷贝基类成员
	D(D &&d):Base(std::move(d)){}    //移动基类成员
	D &operator=(const D &rhs){
		Base::operator=(rhs);
		...
		return *this;
	}
};
```
默认情况下，基类的默认构造函数初始化对象的基类部分，要想是拷贝或移动构造函数，必须在构造函数的初始化列表显式的调用该构造函数。

- 如果构造函数或析构函数调用了某个虚函数，应该执行与构造函数或析构函数所属类型相对应的虚函数版本。因为当创建一个派生类的对象时，首先该对象的基类部分被创建，也就是先调用基类的构造函数，此时该对象的派生类部分还未定义；当销毁这个对象时先执行派生类的析构函数，当执行到基类的析构函数时，意味着该对象的派生类部分已经被释放。所以说，当基类的构造函数调用派生类版本的虚函数时，可能会访问派生类的成员，此时派生类成员还没有定义。如此操作，可能会导致程序崩溃。

- 在C++11新标准中，派生类能够重用其直接基类的构造函数。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。派生类继承基类构造函数的方式是提供了一条注明了（直接）基类名的using声明语句。
```
class Bulk_quote : public Disc_quote{
public:
	using Disc_quote::Disc_quote;    //继承Disc_quote即构造函数
	double net_price(size_t)const;
}
```
**通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。**

- 和普通的using声明不一样，一个构造函数的using声明不会改变其访问级别。例如，不管using声明出现在哪里，基类的私有构造函数在派生类中还是私有；基类中是受保护成员，在派生类中就是受保护的。

- 当一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。比如一个基类构造函数含有两个形参，第二个形参有默认实参，则派生类将获得两个构造函数，一个接受两个形参，一个接受一个形参（左边没有默认实参的那个）。