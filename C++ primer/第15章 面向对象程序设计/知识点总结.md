# 概述
- 面向对象程序设计的核心思想是：**数据抽象，继承和动态绑定**。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似的关系建模；使用动态绑定可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

- 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。在C++中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为**虚函数**。虚函数的声明形式是：在函数的最前面（返回类型前）加上关键字**virtual**。任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
```
class Quote{
public:
	string isbn() const;
	virtual double net_price(size_t n) const;
}
```
- 派生类必须通过使用类派生列表明确指出它是从哪个（哪些）基类继承而来。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前可以有访问说明符。访问说明符的作用是控制派生类从基类继承而来的成员对派生类用户是否可见。如果一个派生是公有的，则基类的公有成员也是派生类的接口的组成部分。此外，还可以将公有派生类型的对象绑定到基类的引用或指针上。
```
class Bulk_quote : public Quote{
public:
	double net_price(size_t n)const override;
}
```

- 派生类必须在其内部对所以重新定义的虚函数进行声明。派生类可以在这些函数前加上virtual关键字，但不是必须这样做。override是C++11新标准规定，用来显式的注明使用哪个成员函数改下基类的虚函数。

- 使用动态绑定可以使用一段代码处理基类和派生类的对象。
```
double print_total(ostream &os,const Quote &item,size_t n){
	double ret = item.net_price(n);
	os<<"ISBN: "<<item.isbn()<<"sold: "<<n<<" total due: "<<ret<<endl;
}
```
因为函数print_total的形参是基类Quote的一个引用，所以，既可以使用基类的对象调用该函数，也可以使用派生类的对象调用该函数。又因为是使用引用类型调用net_price的，所以，实际传入print_total的对象类型将决定到底执行net_price的哪个版本。
```
//basic是基类Quote的一个对象，bulk是派生类的一个对象
print_total(cout,basic,20);
print_total(cout,bulk,20)
```
因为在上述过程中函数的运行版本由实参决定，即在运行时决定函数的版本，所以动态绑定又称为运行时绑定。

- **在C++中，当使用基类的引用或指针调用一个虚函数时，将发生动态绑定。**作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不进行任何操作也是如此。

- 派生类经常但不总是覆盖它继承的虚函数。如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他普通成员函数，派生类会直接继承其在基类中定义的版本。

- 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样子的子对象也有多个。

- 因为在派生类对象中含有与其基类对应的组成部分，所以可以把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换称为派生类到基类的转换 
```
Quote item;    //基类对象
Bulk_quote bulk;    //派生类对象
Quote *p = &item;    ／／p指向基类对象
p = &bulk;   ／／p指向bulk的基类部分
Quote &r = bulk;   ／／r绑定到bulk的基类部分
```
- 尽管在派生类对象中含有从基类继承而来的成员，但是派生类不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。类似于初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数。
```
Bulk_quote(const string &book,double p,size_t qty,double
 disc):Quote(book,p),minqty(qty),discount(disc){ }
```
首先初始化基类成员，然后按照声明顺序依次初始化派生类的成员。

-  如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。而且静态成员遵循通用的访问控制原则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则既可以通过基类使用它，也能通过派生类使用它。
```
class Base{
public:
    static void statmem();
};
class Derived : public Base{
    void f(const Derived &);
private:
	size_t min_qty = 0;
	double discount = 0.0;
};
void Derived::f(const Derived &obj){
    Base::statmem();    //正确，Base定义了statmem
    Derived::statmem();  //正确，Derived继承自Base
    obj.statmem();    //通过派生类对象访问 
    statmem();    //通过this对象访问 
}
```
- 在一个继承链中，如果类A派生B，B派生C，则称B是C的直接基类，A是B的直接基类，A是C的间接基类，因为派生类会包含直接基类的所有成员，该类又包含它的基类的所有成员，以此类推，结果就是：**最终的派生类将包含其直接基类的子对象和每个间接基类的子对象**

- 有时不希望一个类被其他类继承，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C ++11规定了一种防止继承的方法，××在类名后面跟一个关键字final××

- 如果想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则，在继承体系中，可以将基类的指针或引用绑定到派生类对象上，这也就意味着：当使用基类的引用或指针时，实际上并不清楚该引用或指针所绑定的对象的类型。可能是派生类对象，也可能是基类对象。

- 一个表达式有静态类型，也有动态类型。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才知道。就像print-total函数，当实参是bulk-quote时，item的静态类型与动态类型不一致。××如果表达式既不是引用也不是指针，则它的动态类型与静态类型永远一致。××

- 之所以存在派生类向基类的类型转换，是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在，如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换。
```
Quote base;
Bulk_quote* bulkP = &base;    //错误，不能将基类转换成派生类
Bulk_quote& bulkRef = base;   //错误，不能将基类转换成派生类
```
如果这是合法的，那么bulkP和bulkref就可以访问base中本不存在的成员。
即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换：
```
Bulk_quote bulk;
Quote *itemP = &bulk;    // 正确，itemp的动态类型是Bulk-quote
Bulk_quote *bulkP = itemP;   // 错误，不能将基类转换成派生类
```
- 编译器在编译时无法确定某个特定的转换是不是合法的，因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果基类中含有一个或多个虚函数，可以使用dynamic_cast请求一个类型转换，该转换的安全检查在运行时执行，同样，如果已知某个基类向派生类转换是安全的，这可以使用static_cast来强制覆盖掉编译器的转换检查工作。

- 派生类向基类的转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。在基类的拷贝构造函数和拷贝赋值运算符上，当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。

- 虚函数必须有定义，这是因为基类的引用或指针在调用虚函数时会发生动态绑定，只有当运行时才可以知道调用了哪个版本的虚函数。
