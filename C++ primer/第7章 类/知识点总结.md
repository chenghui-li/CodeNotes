# 概述
- 类中常见到跟在形参列表之后的const关键字，它的作用是修改隐式this指针的类型。默认情况下，this的类型是指向类类型非常量版本的常量指针。比如在Animal成员函数中，this的类型是Animal \*const。尽管this是隐式的，但它仍需遵循初始化规则，意味着默认情况下不能把this绑定到一个常量对象上。这也就使得不能在一个常量对象上调用普通的成员函数。更好的方式是显式的修改this的类型为const Animal \*const（如果函数不修改对象成员变量），做法就是在形参列表后加const关键字。

- 类通过一个或几个特殊的成员函数来控制对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时，只要类对象被创建，就会执行类的构造函数。
构造函数有几点需要注意：
1. 构造函数的名字和类名相同。
2. 构造函数没有返回类型。
3. 构造函数的形参列表或函数体可以为空。
4. 构造函数不可以声明成const的。因为当创建一个const对象时，直到构造函数初始化完成，对象才获得其常量属性，构造函数在const对象的构造过程中需要向其写值。

- 如果我们的类没有显式的定义构造函数，则编译器会自动定义默认构造函数，默认构造函数无须任何实参。默认构造函数的初始化规则为：
1. 如果存在类内的初始值，用它来初始化成员。
2. 否则默认初始化该成员。

- 含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未定义的值。

- 在C++11新标准中，如果需要默认的行为，那么可以通过在参数列表后面写上=default来要求编译器生成构造函数。其中=default既可以和声明一起出现在类的内部（内联），也可以作为定义出现在类的外部（非内联）。

- 如果不主动定义拷贝，赋值和销毁操作，编译器会替我们合成它们，将生成对对象的每个成员执行拷贝，赋值和销毁操作。但是对于某些类不能使用合成的版本，特别是当类需要分配类对象以外的资源时，合成的版本常常会失效。如果类包含vector或者string成员，则其拷贝，赋值和销毁的合成版本能够正常工作。当我们对含有vector成员的对象执行拷贝或者赋值操作时，vector类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁vector对象已经vector中的每一个元素。

- 使用class或struct都可以作为定义类的关键字。唯一的区别在于，struct和class的默认访问权限不太一样。类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果使用struct关键字，则定义在第一个访问说明符之前的成员是public；相反，如果使用class关键字，则这些成员是private的。

- 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。但是友元的声明仅仅指定了访问的权限，而非通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，**那么必须在友元声明之外再专门对函数进行一次声明。**

- 在类内定义的成员函数自动是内联的，也可以在类内显式的声明成员函数为inline（在类外定义时不用加inline），也可以在类外定义时再用inline修饰（类内声明时没有inline修饰）。同时在声明和定义处都用inline修饰也是合法的。不过最好是**只在类外部定义的地方说明inline，可以让类更容易理解**。

- 有时希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过**在变量的声明中加入mutable关键字做到这一点**。一个可变数据成员永远不会是const，即使它是const对象的成员。因此一个const成员函数可以修改一个可变数据成员的值。
```
class screen{
public:
	void some_member() const;
private:
	mutable size_t access;
	int cursor = 0;
	int height = 0,width = 0;
	string content;
};
void screen:some_member() const{
	++access;
}
```

- 有时需要改变当前对象的某个成员变量，可以定义返回\*this的成员函数，返回类型为类的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而不是对象的副本。
```
class screen{
public :
	screen &set(char);
	screen &set(int ,int ,char);
};
inline screen &screen::set(char ch){
	content[cursor] = ch;
	return *this;
}
inline screen &screen::set(int r,int col,char ch){
	content[r*width+col] = ch;
	return *this;
}
```
一系列返回引用的函数可以连起来写：
`myScreen.move(4,0).set('#')`
这些操作在同一个对象上执行，等价于：
```
myScreen.move(4,0);
myScreen.set('#');
```
如果令move和set返回screen而不是screen&，上述语句将等价于：
```
screen temp = myScreen.move(4,0);
temp.set('#');
```
move的返回值将是\*this的副本，因此调用set只能改变临时副本，不能改变myScreen的值。

- 必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是自己。然而，一旦一个类的名字出现后，它就被认为是声明过的了（但尚未定义），因此类允许包含指向它自己的指针或引用。

- 有时可以忽略数据成员初始化和赋值之间的差异，但并不总是这样。如果**成员是const，引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初始值**。

- 构造函数初始值中每个成员只能出现一次，它只能说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员的初始化顺序与它们在类中定义出现的顺序一致：第一个成员先被初始化，然后第二个，依次类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。**最好令构造函数初始值的顺序与成员声明的顺序保持一致，尽量避免使用某些成员变量初始化其他成员**。

- 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些或全部职责委托给了其他构造函数。和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另一个构造函数匹配。
```
class sales_data{
	//非委托构造函数
	sales_data(string s,unsigned cnt,double price):bookno(s),units_sold(cnt),revenue(cnt*price){}
	//其余构造函数全部委托给另一个构造函数
	sales_data():sales_data("",0,0){}
	sales_data(string s):sales_data(s,0,0){}

}
```
当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后执行委托者的函数体。

- 在要求隐式转换的上下文中，可以通过将构造函数声明为**explicit**加以阻止：
```
class sales_data{
public:
	sales_data() = default;
	sales_data(const string &s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n){ }
	explicit sales_data(const string &s):bookNo(s){ }
	explicit sales_data(istream&);
};
```
此时，没有任何构造函数能用于隐式的创建sales_data对象。关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外定义时不应重复。

- 聚合类使得用户可以直接访问类的成员，并且具有特殊的初始化语法形式。当一个类满足一下条件时，称之为聚合的：
1. 所有成员都是public的
2. 没有定义任何构造函数
3. 没有类内初始值
4. 没有基类，也没有virtual函数。
```
struct Data{
	int ival;
	string s;
}
```

- 有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。可以通过在成员的声明之前加上static使得其与类关联在一起。称为静态成员。类的静态成员存在于任何对象之外，对象不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且也不能在static函数体内使用this指针。可以直接使用类作用域运算符访问类的静态成员，也可以使用类的对象、引用或指针来访问。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。

- 因为静态数据成员不属于类的任何一个对象，所以它们不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的，而且一般来说，不能在类的内部初始化静态成员。相反，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。类似于全局变量，静态数据成员在任何函数之外。因此它一旦被定义，就将一直存在于程序的整个生命周期。

- 静态成员与普通成员的一个区别是：静态成员可以当做默认实参：
```
class screen{
public:
    screen &clear(char = bkground);    //bkground表示一个在类中稍后定义的静态成员
private:
	static const char bkground;
}
```
